# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxtpro.base.exchange import Exchange
import ccxt.async_support as ccxt
from ccxtpro.base.cache import ArrayCache


class coinbasepro(Exchange, ccxt.coinbasepro):

    def describe(self):
        return self.deep_extend(super(coinbasepro, self).describe(), {
            'has': {
                'ws': True,
                'watchOHLCV': False,  # missing on the exchange side
                'watchOrderBook': True,
                'watchTicker': True,
                'watchTickers': False,  # for now
                'watchTrades': True,
                'watchBalance': False,
                'watchStatus': False,  # for now
            },
            'urls': {
                'api': {
                    'ws': 'wss://ws-feed.pro.coinbase.com',
                },
            },
        })

    async def subscribe(self, name, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        messageHash = name + ':' + market['id']
        url = self.urls['api']['ws']
        subscribe = {
            'type': 'subscribe',
            'product_ids': [
                market['id'],
            ],
            'channels': [
                name,
            ],
        }
        request = self.extend(subscribe, params)
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_ticker(self, symbol, params={}):
        name = 'ticker'
        return await self.subscribe(name, symbol, params)

    async def watch_trades(self, symbol, since=None, limit=None, params={}):
        name = 'matches'
        future = self.subscribe(name, symbol, params)
        return await self.after(future, self.filter_by_since_limit, since, limit, 'timestamp', True)

    async def watch_order_book(self, symbol, limit=None, params={}):
        name = 'level2'
        await self.load_markets()
        market = self.market(symbol)
        messageHash = name + ':' + market['id']
        url = self.urls['api']['ws']
        subscribe = {
            'type': 'subscribe',
            'product_ids': [
                market['id'],
            ],
            'channels': [
                name,
            ],
        }
        request = self.extend(subscribe, params)
        subscription = {
            'messageHash': messageHash,
            'symbol': symbol,
            'marketId': market['id'],
            'limit': limit,
        }
        future = self.watch(url, messageHash, request, messageHash, subscription)
        # self.subscribe(name, symbol, params)
        return await self.after(future, self.limit_order_book, symbol, limit, params)

    def handle_trade(self, client, message):
        #
        #     {
        #         type: 'match',
        #         trade_id: 82047307,
        #         maker_order_id: '0f358725-2134-435e-be11-753912a326e0',
        #         taker_order_id: '252b7002-87a3-425c-ac73-f5b9e23f3caf',
        #         side: 'sell',
        #         size: '0.00513192',
        #         price: '9314.78',
        #         product_id: 'BTC-USD',
        #         sequence: 12038915443,
        #         time: '2020-01-31T20:03:41.158814Z'
        #     }
        #
        marketId = self.safe_string(message, 'product_id')
        if marketId is not None:
            trade = self.parse_trade(message)
            symbol = trade['symbol']
            # the exchange sends type = 'match'
            # but requires 'matches' upon subscribing
            # therefore we resolve 'matches' here instead of 'match'
            # type = self.safe_string(message, 'type')
            type = 'matches'
            messageHash = type + ':' + marketId
            array = self.safe_value(self.trades, symbol)
            if array is None:
                tradesLimit = self.safe_integer(self.options, 'tradesLimit', 1000)
                array = ArrayCache(tradesLimit)
                self.trades[symbol] = array
            array.append(trade)
            client.resolve(array, messageHash)
        return message

    def handle_ticker(self, client, message):
        #
        #     {
        #         type: 'ticker',
        #         sequence: 12042642428,
        #         product_id: 'BTC-USD',
        #         price: '9380.55',
        #         open_24h: '9450.81000000',
        #         volume_24h: '9611.79166047',
        #         low_24h: '9195.49000000',
        #         high_24h: '9475.19000000',
        #         volume_30d: '327812.00311873',
        #         best_bid: '9380.54',
        #         best_ask: '9380.55',
        #         side: 'buy',
        #         time: '2020-02-01T01:40:16.253563Z',
        #         trade_id: 82062566,
        #         last_size: '0.41969131'
        #     }
        #
        marketId = self.safe_string(message, 'product_id')
        if marketId is not None:
            ticker = self.parse_ticker(message)
            symbol = ticker['symbol']
            self.tickers[symbol] = ticker
            type = self.safe_string(message, 'type')
            messageHash = type + ':' + marketId
            client.resolve(ticker, messageHash)
        return message

    def parse_ticker(self, ticker, market=None):
        #
        #     {
        #         type: 'ticker',
        #         sequence: 12042642428,
        #         product_id: 'BTC-USD',
        #         price: '9380.55',
        #         open_24h: '9450.81000000',
        #         volume_24h: '9611.79166047',
        #         low_24h: '9195.49000000',
        #         high_24h: '9475.19000000',
        #         volume_30d: '327812.00311873',
        #         best_bid: '9380.54',
        #         best_ask: '9380.55',
        #         side: 'buy',
        #         time: '2020-02-01T01:40:16.253563Z',
        #         trade_id: 82062566,
        #         last_size: '0.41969131'
        #     }
        #
        type = self.safe_string(ticker, 'type')
        if type is None:
            return super(coinbasepro, self).parse_ticker(ticker, market)
        marketId = self.safe_string(ticker, 'product_id')
        symbol = self.safe_symbol(marketId, market, '-')
        timestamp = self.parse8601(self.safe_string(ticker, 'time'))
        last = self.safe_float(ticker, 'price')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high_24h'),
            'low': self.safe_float(ticker, 'low_24h'),
            'bid': self.safe_float(ticker, 'best_bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'best_ask'),
            'askVolume': None,
            'vwap': None,
            'open': self.safe_float(ticker, 'open_24h'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume_24h'),
            'quoteVolume': None,
            'info': ticker,
        }

    def handle_delta(self, bookside, delta):
        price = self.safe_float(delta, 0)
        amount = self.safe_float(delta, 1)
        bookside.store(price, amount)

    def handle_deltas(self, bookside, deltas):
        for i in range(0, len(deltas)):
            self.handle_delta(bookside, deltas[i])

    def handle_order_book(self, client, message):
        #
        # first message(snapshot)
        #
        #     {
        #         "type": "snapshot",
        #         "product_id": "BTC-USD",
        #         "bids": [
        #             ["10101.10", "0.45054140"]
        #         ],
        #         "asks": [
        #             ["10102.55", "0.57753524"]
        #         ]
        #     }
        #
        # subsequent updates
        #
        #     {
        #         "type": "l2update",
        #         "product_id": "BTC-USD",
        #         "time": "2019-08-14T20:42:27.265Z",
        #         "changes": [
        #             ["buy", "10101.80000000", "0.162567"]
        #         ]
        #     }
        #
        type = self.safe_string(message, 'type')
        marketId = self.safe_string(message, 'product_id')
        market = self.safe_market(marketId, None, '-')
        symbol = market['symbol']
        name = 'level2'
        messageHash = name + ':' + marketId
        subscription = self.safe_value(client.subscriptions, messageHash, {})
        limit = self.safe_integer(subscription, 'limit')
        if type == 'snapshot':
            self.orderbooks[symbol] = self.order_book({}, limit)
            orderbook = self.orderbooks[symbol]
            self.handle_deltas(orderbook['asks'], self.safe_value(message, 'asks', []))
            self.handle_deltas(orderbook['bids'], self.safe_value(message, 'bids', []))
            orderbook['timestamp'] = None
            orderbook['datetime'] = None
            client.resolve(orderbook, messageHash)
        elif type == 'l2update':
            orderbook = self.orderbooks[symbol]
            timestamp = self.parse8601(self.safe_string(message, 'time'))
            changes = self.safe_value(message, 'changes', [])
            sides = {
                'sell': 'asks',
                'buy': 'bids',
            }
            for i in range(0, len(changes)):
                change = changes[i]
                key = self.safe_string(change, 0)
                side = self.safe_string(sides, key)
                price = self.safe_float(change, 1)
                amount = self.safe_float(change, 2)
                bookside = orderbook[side]
                bookside.store(price, amount)
            orderbook['timestamp'] = timestamp
            orderbook['datetime'] = self.iso8601(timestamp)
            client.resolve(orderbook, messageHash)

    def handle_subscription_status(self, client, message):
        #
        #     {
        #         type: 'subscriptions',
        #         channels: [
        #             {
        #                 name: 'level2',
        #                 product_ids: ['ETH-BTC']
        #             }
        #         ]
        #     }
        #
        return message

    def handle_message(self, client, message):
        type = self.safe_string(message, 'type')
        methods = {
            'snapshot': self.handle_order_book,
            'l2update': self.handle_order_book,
            'subscribe': self.handle_subscription_status,
            'match': self.handle_trade,
            'ticker': self.handle_ticker,
        }
        method = self.safe_value(methods, type)
        if method is None:
            return message
        else:
            return method(client, message)
