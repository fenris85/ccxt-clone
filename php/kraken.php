<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\NotSupported;

class kraken extends \ccxt\kraken {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => false, // no such type of subscription as of 2021-01-05
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                // 'watchHeartbeat' => true,
                // 'watchStatus' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://ws.kraken.com',
                        'private' => 'wss://ws-auth.kraken.com',
                        'beta' => 'wss://beta-ws.kraken.com',
                    ),
                ),
            ),
            'versions' => array(
                'ws' => '0.2.0',
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                        'Event(s) not found' => '\\ccxt\\BadRequest',
                    ),
                    'broad' => array(
                        'Currency pair not in ISO 4217-A3 format' => '\\ccxt\\BadSymbol',
                    ),
                ),
            ),
        ));
    }

    public function handle_ticker($client, $message, $subscription) {
        //
        //     array(
        //         0, // channelID
        //         array(
        //             "a" => array( "5525.40000", 1, "1.000" ), // ask, wholeAskVolume, askVolume
        //             "b" => array( "5525.10000", 1, "1.000" ), // bid, wholeBidVolume, bidVolume
        //             "c" => array( "5525.10000", "0.00398963" ), // closing price, volume
        //             "h" => array( "5783.00000", "5783.00000" ), // high price today, high price 24h ago
        //             "l" => array( "5505.00000", "5505.00000" ), // low price today, low price 24h ago
        //             "o" => array( "5760.70000", "5763.40000" ), // open price today, open price 24h ago
        //             "p" => array( "5631.44067", "5653.78939" ), // $vwap today, $vwap 24h ago
        //             "t" => array( 11493, 16267 ), // number of trades today, 24 hours ago
        //             "v" => array( "2634.11501494", "3591.17907851" ), // volume today, volume 24 hours ago
        //         ),
        //         "$ticker",
        //         "XBT/USD"
        //     )
        //
        $wsName = $message[3];
        $name = 'ticker';
        $messageHash = $name . ':' . $wsName;
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $ticker = $message[1];
        $vwap = $this->safe_float($ticker['p'], 0);
        $quoteVolume = null;
        $baseVolume = $this->safe_float($ticker['v'], 0);
        if ($baseVolume !== null && $vwap !== null) {
            $quoteVolume = $baseVolume * $vwap;
        }
        $last = $this->safe_float($ticker['c'], 0);
        $timestamp = $this->milliseconds();
        $result = array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_float($ticker['h'], 0),
            'low' => $this->safe_float($ticker['l'], 0),
            'bid' => $this->safe_float($ticker['b'], 0),
            'bidVolume' => $this->safe_float($ticker['b'], 2),
            'ask' => $this->safe_float($ticker['a'], 0),
            'askVolume' => $this->safe_float($ticker['a'], 2),
            'vwap' => $vwap,
            'open' => $this->safe_float($ticker['o'], 0),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        );
        // todo add support for multiple tickers (may be tricky)
        // kraken confirms multi-pair subscriptions separately one by one
        // trigger correct watchTickers calls upon receiving any of symbols
        $this->tickers[$symbol] = $result;
        $client->resolve ($result, $messageHash);
    }

    public function handle_trades($client, $message, $subscription) {
        //
        //     array(
        //         0, // channelID
        //         array( //     price        volume         time             side type misc
        //             array( "5541.20000", "0.15850568", "1534614057.321597", "s", "l", "" ),
        //             array( "6060.00000", "0.02455000", "1534614057.324998", "b", "l", "" ),
        //         ),
        //         "trade",
        //         "XBT/USD"
        //     )
        //
        $wsName = $this->safe_string($message, 3);
        $name = $this->safe_string($message, 2);
        $messageHash = $name . ':' . $wsName;
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $trades = $this->safe_value($message, 1, array());
        $parsed = $this->parse_trades($trades, $market);
        for ($i = 0; $i < count($parsed); $i++) {
            $stored->append ($parsed[$i]);
        }
        $client->resolve ($stored, $messageHash);
    }

    public function handle_ohlcv($client, $message, $subscription) {
        //
        //     array(
        //         216, // channelID
        //         array(
        //             '1574454214.962096', // Time, seconds since epoch
        //             '1574454240.000000', // End $timestamp of the $interval
        //             '0.020970', // Open price at midnight UTC
        //             '0.020970', // Intraday high price
        //             '0.020970', // Intraday low price
        //             '0.020970', // Closing price at midnight UTC
        //             '0.020970', // Volume weighted average price
        //             '0.08636138', // Accumulated volume today
        //             1, // Number of trades today
        //         ),
        //         'ohlc-1', // Channel Name of $subscription
        //         'ETH/XBT', // Asset pair
        //     )
        //
        $info = $this->safe_value($subscription, 'subscription', array());
        $interval = $this->safe_integer($info, 'interval');
        $name = $this->safe_string($info, 'name');
        $wsName = $this->safe_string($message, 3);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $timeframe = $this->find_timeframe($interval);
        $duration = $this->parse_timeframe($timeframe);
        if ($timeframe !== null) {
            $candle = $this->safe_value($message, 1);
            $messageHash = $name . ':' . $timeframe . ':' . $wsName;
            $timestamp = $this->safe_float($candle, 1);
            $timestamp -= $duration;
            $result = array(
                intval($timestamp * 1000),
                $this->safe_float($candle, 2),
                $this->safe_float($candle, 3),
                $this->safe_float($candle, 4),
                $this->safe_float($candle, 5),
                $this->safe_float($candle, 7),
            );
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCache ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $length = is_array($stored) ? count($stored) : 0;
            if ($length && $result[0] === $stored[$length - 1][0]) {
                $stored[$length - 1] = $result;
            } else {
                $stored->append ($result);
            }
            $client->resolve ($stored, $messageHash);
        }
    }

    public function request_id() {
        // their support said that $reqid must be an int32, not documented
        $reqid = $this->sum($this->safe_integer($this->options, 'reqid', 0), 1);
        $this->options['reqid'] = $reqid;
        return $reqid;
    }

    public function watch_public($name, $symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $wsName = $this->safe_value($market['info'], 'wsname');
        $messageHash = $name . ':' . $wsName;
        $url = $this->urls['api']['ws']['public'];
        $requestId = $this->request_id();
        $subscribe = array(
            'event' => 'subscribe',
            'reqid' => $requestId,
            'pair' => array(
                $wsName,
            ),
            'subscription' => array(
                'name' => $name,
            ),
        );
        $request = $this->deep_extend($subscribe, $params);
        return $this->watch($url, $messageHash, $request, $messageHash);
    }

    public function watch_ticker($symbol, $params = array ()) {
        return $this->watch_public('ticker', $symbol, $params);
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $name = 'trade';
        $future = $this->watch_public($name, $symbol, $params);
        return $this->after($future, array($this, 'filter_by_since_limit'), $since, $limit, 'timestamp', true);
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        $name = 'book';
        $request = array();
        if ($limit !== null) {
            if (($limit === 10) || ($limit === 25) || ($limit === 100) || ($limit === 500) || ($limit === 1000)) {
                $request['subscription'] = array(
                    'depth' => $limit, // default 10, valid options 10, 25, 100, 500, 1000
                );
            } else {
                throw new NotSupported($this->id . ' watchOrderBook accepts $limit values of 10, 25, 100, 500 and 1000 only');
            }
        }
        $future = $this->watch_public($name, $symbol, array_merge($request, $params));
        return $this->after($future, array($this, 'limit_order_book'), $symbol, $limit, $params);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $name = 'ohlc';
        $market = $this->market($symbol);
        $wsName = $this->safe_value($market['info'], 'wsname');
        $messageHash = $name . ':' . $timeframe . ':' . $wsName;
        $url = $this->urls['api']['ws']['public'];
        $requestId = $this->request_id();
        $subscribe = array(
            'event' => 'subscribe',
            'reqid' => $requestId,
            'pair' => array(
                $wsName,
            ),
            'subscription' => array(
                'name' => $name,
                'interval' => $this->timeframes[$timeframe],
            ),
        );
        $request = $this->deep_extend($subscribe, $params);
        $future = $this->watch($url, $messageHash, $request, $messageHash);
        return $this->after($future, array($this, 'filter_by_since_limit'), $since, $limit, 0, true);
    }

    public function load_markets($reload = false, $params = array ()) {
        $markets = parent::load_markets($reload, $params);
        $marketsByWsName = $this->safe_value($this->options, 'marketsByWsName');
        if (($marketsByWsName === null) || $reload) {
            $marketsByWsName = array();
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $market = $this->markets[$symbol];
                if (!$market['darkpool']) {
                    $info = $this->safe_value($market, 'info', array());
                    $wsName = $this->safe_string($info, 'wsname');
                    $marketsByWsName[$wsName] = $market;
                }
            }
            $this->options['marketsByWsName'] = $marketsByWsName;
        }
        return $markets;
    }

    public function watch_heartbeat($params = array ()) {
        $this->load_markets();
        $event = 'heartbeat';
        $url = $this->urls['api']['ws']['public'];
        return $this->watch($url, $event);
    }

    public function handle_heartbeat($client, $message) {
        //
        // every second (approx) if no other updates are sent
        //
        //     array( "$event" => "heartbeat" )
        //
        $event = $this->safe_string($message, 'event');
        $client->resolve ($message, $event);
    }

    public function handle_order_book($client, $message, $subscription) {
        //
        // first $message (snapshot)
        //
        //     array(
        //         1234, // channelID
        //         array(
        //             "as" => array(
        //                 array( "5541.30000", "2.50700000", "1534614248.123678" ),
        //                 array( "5541.80000", "0.33000000", "1534614098.345543" ),
        //                 array( "5542.70000", "0.64700000", "1534614244.654432" )
        //             ),
        //             "bs" => array(
        //                 array( "5541.20000", "1.52900000", "1534614248.765567" ),
        //                 array( "5539.90000", "0.30000000", "1534614241.769870" ),
        //                 array( "5539.50000", "5.00000000", "1534613831.243486" )
        //             )
        //         ),
        //         "book-10",
        //         "XBT/USD"
        //     )
        //
        // subsequent updates
        //
        //     array(
        //         1234,
        //         array( // optional
        //             "$a" => array(
        //                 array( "5541.30000", "2.50700000", "1534614248.456738" ),
        //                 array( "5542.50000", "0.40100000", "1534614248.456738" )
        //             )
        //         ),
        //         array( // optional
        //             "$b" => array(
        //                 array( "5541.30000", "0.00000000", "1534614335.345903" )
        //             )
        //         ),
        //         "book-10",
        //         "XBT/USD"
        //     )
        //
        $messageLength = is_array($message) ? count($message) : 0;
        $wsName = $message[$messageLength - 1];
        $bookDepthString = $message[$messageLength - 2];
        $parts = explode('-', $bookDepthString);
        $depth = $this->safe_integer($parts, 1, 10);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName);
        $symbol = $market['symbol'];
        $timestamp = null;
        $messageHash = 'book:' . $wsName;
        // if this is $a snapshot
        if (is_array($message[1]) && array_key_exists('as', $message[1])) {
            // todo get $depth from marketsByWsName
            $this->orderbooks[$symbol] = $this->order_book(array(), $depth);
            $orderbook = $this->orderbooks[$symbol];
            $sides = array(
                'as' => 'asks',
                'bs' => 'bids',
            );
            $keys = is_array($sides) ? array_keys($sides) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $side = $sides[$key];
                $bookside = $orderbook[$side];
                $deltas = $this->safe_value($message[1], $key, array());
                $timestamp = $this->handle_deltas($bookside, $deltas, $timestamp);
            }
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            $client->resolve ($orderbook, $messageHash);
        } else {
            $orderbook = $this->orderbooks[$symbol];
            // else, if this is an $orderbook update
            $a = null;
            $b = null;
            if ($messageLength === 5) {
                $a = $this->safe_value($message[1], 'a', array());
                $b = $this->safe_value($message[2], 'b', array());
            } else {
                if (is_array($message[1]) && array_key_exists('a', $message[1])) {
                    $a = $this->safe_value($message[1], 'a', array());
                } else {
                    $b = $this->safe_value($message[1], 'b', array());
                }
            }
            if ($a !== null) {
                $timestamp = $this->handle_deltas($orderbook['asks'], $a, $timestamp);
            }
            if ($b !== null) {
                $timestamp = $this->handle_deltas($orderbook['bids'], $b, $timestamp);
            }
            $orderbook['timestamp'] = $timestamp;
            $orderbook['datetime'] = $this->iso8601($timestamp);
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_deltas($bookside, $deltas, $timestamp) {
        for ($j = 0; $j < count($deltas); $j++) {
            $delta = $deltas[$j];
            $price = floatval($delta[0]);
            $amount = floatval($delta[1]);
            $timestamp = max ($timestamp || 0, intval(floatval($delta[2]) * 1000));
            $bookside->store ($price, $amount);
        }
        return $timestamp;
    }

    public function handle_system_status($client, $message) {
        //
        // todo => answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         connectionID => 15527282728335292000,
        //         event => 'systemStatus',
        //         status => 'online', // online|maintenance|(custom status tbd)
        //         version => '0.2.0'
        //     }
        //
        return $message;
    }

    public function authenticate($params = array ()) {
        $url = $this->urls['api']['ws']['private'];
        $client = $this->client($url);
        $authenticated = 'authenticated';
        $subscription = $this->safe_value($client->subscriptions, $authenticated);
        if ($subscription === null) {
            $response = $this->privatePostGetWebSocketsToken ($params);
            //
            //     {
            //         "error":array(),
            //         "result":{
            //             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
            //             "expires":900
            //         }
            //     }
            //
            $subscription = $this->safe_value($response, 'result');
            $client->subscriptions[$authenticated] = $subscription;
        }
        return $this->safe_string($subscription, 'token');
    }

    public function watch_private($name, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $token = $this->authenticate();
        $subscriptionHash = $name;
        $messageHash = $name;
        if ($symbol !== null) {
            $messageHash .= ':' . $symbol;
        }
        $url = $this->urls['api']['ws']['private'];
        $requestId = $this->request_id();
        $subscribe = array(
            'event' => 'subscribe',
            'reqid' => $requestId,
            'subscription' => array(
                'name' => $name,
                'token' => $token,
            ),
        );
        $request = $this->deep_extend($subscribe, $params);
        $future = $this->watch($url, $messageHash, $request, $subscriptionHash);
        return $this->after($future, array($this, 'filter_by_symbol_since_limit'), $symbol, $since, $limit);
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->watch_private('ownTrades', $symbol, $since, $limit, $params);
    }

    public function handle_my_trades($client, $message, $subscription = null) {
        //
        //     array(
        //         array(
        //             {
        //                 'TT5UC3-GOIRW-6AZZ6R' => array(
        //                     cost => '1493.90107',
        //                     fee => '3.88415',
        //                     margin => '0.00000',
        //                     ordertxid => 'OTLAS3-RRHUF-NDWH5A',
        //                     ordertype => 'market',
        //                     pair => 'XBT/USDT',
        //                     postxid => 'TKH2SE-M7IF5-CFI7LT',
        //                     price => '6851.50005',
        //                     time => '1586822919.335498',
        //                     type => 'sell',
        //                     vol => '0.21804000'
        //                 }
        //             ),
        //             {
        //                 'TIY6G4-LKLAI-Y3GD4A' => array(
        //                     cost => '22.17134',
        //                     fee => '0.05765',
        //                     margin => '0.00000',
        //                     ordertxid => 'ODQXS7-MOLK6-ICXKAA',
        //                     ordertype => 'market',
        //                     pair => 'ETH/USD',
        //                     postxid => 'TKH2SE-M7IF5-CFI7LT',
        //                     price => '169.97999',
        //                     time => '1586340530.895739',
        //                     type => 'buy',
        //                     vol => '0.13043500'
        //                 }
        //             ),
        //         ),
        //         'ownTrades',
        //         array( sequence => 1 )
        //     )
        //
        $allTrades = $this->safe_value($message, 0, array());
        $allTradesLength = is_array($allTrades) ? count($allTrades) : 0;
        if ($allTradesLength > 0) {
            if ($this->myTrades === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $this->myTrades = new ArrayCache ($limit);
            }
            $stored = $this->myTrades;
            $symbols = array();
            for ($i = 0; $i < count($allTrades); $i++) {
                $trades = $this->safe_value($allTrades, $i, array());
                $ids = is_array($trades) ? array_keys($trades) : array();
                for ($j = 0; $j < count($ids); $j++) {
                    $id = $ids[$j];
                    $trade = $trades[$id];
                    $parsed = $this->parse_ws_trade(array_merge(array( 'id' => $id ), $trade));
                    $stored->append ($parsed);
                    $symbol = $parsed['symbol'];
                    $symbols[$symbol] = true;
                }
            }
            $name = 'ownTrades';
            $client->resolve ($this->myTrades, $name);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $messageHash = $name . ':' . $keys[$i];
                $client->resolve ($this->myTrades, $messageHash);
            }
        }
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        //     {
        //         $id => 'TIMIRG-WUNNE-RRJ6GT', // injected from outside
        //         ordertxid => 'OQRPN2-LRHFY-HIFA7D',
        //         postxid => 'TKH2SE-M7IF5-CFI7LT',
        //         pair => 'USDCUSDT',
        //         time => 1586340086.457,
        //         $type => 'sell',
        //         ordertype => 'market',
        //         $price => '0.99860000',
        //         $cost => '22.16892001',
        //         $fee => '0.04433784',
        //         vol => '22.20000000',
        //         margin => '0.00000000',
        //         misc => ''
        //     }
        //
        //     {
        //         $id => 'TIY6G4-LKLAI-Y3GD4A',
        //         $cost => '22.17134',
        //         $fee => '0.05765',
        //         margin => '0.00000',
        //         ordertxid => 'ODQXS7-MOLK6-ICXKAA',
        //         ordertype => 'market',
        //         pair => 'ETH/USD',
        //         postxid => 'TKH2SE-M7IF5-CFI7LT',
        //         $price => '169.97999',
        //         time => '1586340530.895739',
        //         $type => 'buy',
        //         vol => '0.13043500'
        //     }
        //
        $wsName = $this->safe_string($trade, 'pair');
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName, $market);
        $symbol = null;
        $orderId = $this->safe_string($trade, 'ordertxid');
        $id = $this->safe_string_2($trade, 'id', 'postxid');
        $timestamp = $this->safe_timestamp($trade, 'time');
        $side = $this->safe_string($trade, 'type');
        $type = $this->safe_string($trade, 'ordertype');
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'vol');
        $cost = null;
        $fee = null;
        if (is_array($trade) && array_key_exists('fee', $trade)) {
            $currency = null;
            if ($market !== null) {
                $currency = $market['quote'];
            }
            $fee = array(
                'cost' => $this->safe_float($trade, 'fee'),
                'currency' => $currency,
            );
        }
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        if ($price !== null) {
            if ($amount !== null) {
                $cost = $price * $amount;
            }
        }
        return array(
            'id' => $id,
            'order' => $orderId,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->watch_private('openOrders', $symbol, $since, $limit, $params);
    }

    public function handle_orders($client, $message, $subscription = null) {
        //
        //     array(
        //         array(
        //             {
        //                 "OGTT3Y-C6I3P-XRI6HX" => array(
        //                     "cost" => "0.00000",
        //                     "descr" => array(
        //                         "close" => "",
        //                         "leverage" => "0:1",
        //                         "$order" => "sell 10.00345345 XBT/EUR @ $limit 34.50000 with 0:1 leverage",
        //                         "ordertype" => "$limit",
        //                         "pair" => "XBT/EUR",
        //                         "price" => "34.50000",
        //                         "price2" => "0.00000",
        //                         "type" => "sell"
        //                     ),
        //                     "expiretm" => "0.000000",
        //                     "fee" => "0.00000",
        //                     "limitprice" => "34.50000",
        //                     "misc" => "",
        //                     "oflags" => "fcib",
        //                     "opentm" => "0.000000",
        //                     "price" => "34.50000",
        //                     "refid" => "OKIVMP-5GVZN-Z2D2UA",
        //                     "starttm" => "0.000000",
        //                     "status" => "open",
        //                     "stopprice" => "0.000000",
        //                     "userref" => 0,
        //                     "vol" => "10.00345345",
        //                     "vol_exec" => "0.00000000"
        //                 }
        //             ),
        //             {
        //                 "OGTT3Y-C6I3P-XRI6HX" => array(
        //                     "cost" => "0.00000",
        //                     "descr" => array(
        //                         "close" => "",
        //                         "leverage" => "0:1",
        //                         "$order" => "sell 0.00000010 XBT/EUR @ $limit 5334.60000 with 0:1 leverage",
        //                         "ordertype" => "$limit",
        //                         "pair" => "XBT/EUR",
        //                         "price" => "5334.60000",
        //                         "price2" => "0.00000",
        //                         "type" => "sell"
        //                     ),
        //                     "expiretm" => "0.000000",
        //                     "fee" => "0.00000",
        //                     "limitprice" => "5334.60000",
        //                     "misc" => "",
        //                     "oflags" => "fcib",
        //                     "opentm" => "0.000000",
        //                     "price" => "5334.60000",
        //                     "refid" => "OKIVMP-5GVZN-Z2D2UA",
        //                     "starttm" => "0.000000",
        //                     "status" => "open",
        //                     "stopprice" => "0.000000",
        //                     "userref" => 0,
        //                     "vol" => "0.00000010",
        //                     "vol_exec" => "0.00000000"
        //                 }
        //             ),
        //         ),
        //         "openOrders",
        //         array( "sequence" => 234 )
        //     )
        //
        // status-change
        //
        //     array(
        //         array(
        //             array( "OGTT3Y-C6I3P-XRI6HX" => array( "status" => "closed" )),
        //             array( "OGTT3Y-C6I3P-XRI6HX" => array( "status" => "closed" )),
        //         ),
        //         "openOrders",
        //         array( "sequence" => 59342 )
        //     )
        //
        $allOrders = $this->safe_value($message, 0, array());
        $allOrdersLength = is_array($allOrders) ? count($allOrders) : 0;
        if ($allOrdersLength > 0) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheById ($limit);
            }
            $stored = $this->orders;
            $symbols = array();
            for ($i = 0; $i < count($allOrders); $i++) {
                $orders = $this->safe_value($allOrders, $i, array());
                $ids = is_array($orders) ? array_keys($orders) : array();
                for ($j = 0; $j < count($ids); $j++) {
                    $id = $ids[$j];
                    $order = $orders[$id];
                    $previousOrder = $this->safe_value($stored->index, $id);
                    if ($previousOrder !== null) {
                        $order = array_merge($previousOrder['info'], $order);
                    }
                    $parsed = $this->parse_ws_order(array_merge(array( 'id' => $id ), $order));
                    $stored->append ($parsed);
                    $symbol = $parsed['symbol'];
                    $symbols[$symbol] = true;
                }
            }
            $name = 'openOrders';
            $client->resolve ($this->orders, $name);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $messageHash = $name . ':' . $keys[$i];
                $client->resolve ($this->orders, $messageHash);
            }
        }
    }

    public function parse_ws_order($order, $market = null) {
        //
        // createOrder
        //
        //     {
        //         descr => array( $order => 'buy 0.02100000 ETHUSDT @ limit 330.00' ),
        //         $txid => array( 'OEKVV2-IH52O-TPL6GZ' )
        //     }
        //
        $description = $this->safe_value($order, 'descr', array());
        $orderDescription = $this->safe_string($description, 'order');
        $side = null;
        $type = null;
        $wsName = null;
        $price = null;
        $amount = null;
        if ($orderDescription !== null) {
            $parts = explode(' ', $orderDescription);
            $side = $this->safe_string($parts, 0);
            $amount = $this->safe_float($parts, 1);
            $wsName = $this->safe_string($parts, 2);
            $type = $this->safe_string($parts, 4);
            $price = $this->safe_float($parts, 5);
        }
        $side = $this->safe_string($description, 'type', $side);
        $type = $this->safe_string($description, 'ordertype', $type);
        $wsName = $this->safe_string($description, 'pair', $wsName);
        $market = $this->safe_value($this->options['marketsByWsName'], $wsName, $market);
        $symbol = null;
        $timestamp = $this->safe_timestamp($order, 'opentm');
        $amount = $this->safe_float($order, 'vol', $amount);
        $filled = $this->safe_float($order, 'vol_exec');
        $remaining = null;
        if (($amount !== null) && ($filled !== null)) {
            $remaining = $amount - $filled;
        }
        $fee = null;
        $cost = $this->safe_float($order, 'cost');
        $price = $this->safe_float($description, 'price', $price);
        if (($price === null) || ($price === 0.0)) {
            $price = $this->safe_float($description, 'price2');
        }
        if (($price === null) || ($price === 0.0)) {
            $price = $this->safe_float($order, 'price', $price);
        }
        $average = $this->safe_float($order, 'price');
        if ($market !== null) {
            $symbol = $market['symbol'];
            if (is_array($order) && array_key_exists('fee', $order)) {
                $flags = $order['oflags'];
                $feeCost = $this->safe_float($order, 'fee');
                $fee = array(
                    'cost' => $feeCost,
                    'rate' => null,
                );
                if (mb_strpos($flags, 'fciq') !== false) {
                    $fee['currency'] = $market['quote'];
                } else if (mb_strpos($flags, 'fcib') !== false) {
                    $fee['currency'] = $market['base'];
                }
            }
        }
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $id = $this->safe_string($order, 'id');
        if ($id === null) {
            $txid = $this->safe_value($order, 'txid');
            $id = $this->safe_string($txid, 0);
        }
        $clientOrderId = $this->safe_string($order, 'userref');
        $rawTrades = $this->safe_value($order, 'trades');
        $trades = null;
        if ($rawTrades !== null) {
            $trades = $this->parse_trades($rawTrades, $market, null, null, array( 'order' => $id ));
        }
        $stopPrice = $this->safe_float($order, 'stopprice');
        return array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'info' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'average' => $average,
            'remaining' => $remaining,
            'fee' => $fee,
            'trades' => $trades,
        );
    }

    public function handle_subscription_status($client, $message) {
        //
        // public
        //
        //     {
        //         channelID => 210,
        //         channelName => 'book-10',
        //         event => 'subscriptionStatus',
        //         reqid => 1574146735269,
        //         pair => 'ETH/XBT',
        //         status => 'subscribed',
        //         subscription => array( depth => 10, name => 'book' )
        //     }
        //
        // private
        //
        //     {
        //         channelName => 'openOrders',
        //         event => 'subscriptionStatus',
        //         reqid => 1,
        //         status => 'subscribed',
        //         subscription => array( maxratecount => 125, name => 'openOrders' )
        //     }
        //
        $channelId = $this->safe_string($message, 'channelID');
        if ($channelId !== null) {
            $client->subscriptions[$channelId] = $message;
        }
        // $requestId = $this->safe_string($message, 'reqid');
        // if (is_array($client->futures) && array_key_exists($requestId, $client->futures)) {
        //     unset($client->futures[$requestId]);
        // }
    }

    public function handle_error_message($client, $message) {
        //
        //     {
        //         $errorMessage => 'Currency pair not in ISO 4217-A3 format foobar',
        //         event => 'subscriptionStatus',
        //         pair => 'foobar',
        //         reqid => 1574146735269,
        //         status => 'error',
        //         subscription => array( name => 'ticker' )
        //     }
        //
        $errorMessage = $this->safe_value($message, 'errorMessage');
        if ($errorMessage !== null) {
            $requestId = $this->safe_value($message, 'reqid');
            if ($requestId !== null) {
                $broad = $this->exceptions['ws']['broad'];
                $broadKey = $this->find_broadly_matched_key($broad, $errorMessage);
                $exception = null;
                if ($broadKey === null) {
                    $exception = new ExchangeError ($errorMessage);
                } else {
                    $exception = new $broad[$broadKey] ($errorMessage);
                }
                $client->reject ($exception, $requestId);
                return false;
            }
        }
        return true;
    }

    public function handle_message($client, $message) {
        if (gettype($message) === 'array' && count(array_filter(array_keys($message), 'is_string')) == 0) {
            $channelId = $this->safe_string($message, 0);
            $subscription = $this->safe_value($client->subscriptions, $channelId, array());
            $info = $this->safe_value($subscription, 'subscription', array());
            $messageLength = is_array($message) ? count($message) : 0;
            $channelName = $this->safe_string($message, $messageLength - 2);
            $name = $this->safe_string($info, 'name');
            $methods = array(
                // public
                'book' => array($this, 'handle_order_book'),
                'ohlc' => array($this, 'handle_ohlcv'),
                'ticker' => array($this, 'handle_ticker'),
                'trade' => array($this, 'handle_trades'),
                // private
                'openOrders' => array($this, 'handle_orders'),
                'ownTrades' => array($this, 'handle_my_trades'),
            );
            $method = $this->safe_value_2($methods, $name, $channelName);
            if ($method === null) {
                return $message;
            } else {
                return $method($client, $message, $subscription);
            }
        } else {
            if ($this->handle_error_message($client, $message)) {
                $event = $this->safe_string($message, 'event');
                $methods = array(
                    'heartbeat' => array($this, 'handle_heartbeat'),
                    'systemStatus' => array($this, 'handle_system_status'),
                    'subscriptionStatus' => array($this, 'handle_subscription_status'),
                );
                $method = $this->safe_value($methods, $event);
                if ($method === null) {
                    return $message;
                } else {
                    return $method($client, $message);
                }
            }
        }
    }
}
