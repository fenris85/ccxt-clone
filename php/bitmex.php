<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\AuthenticationError;

class bitmex extends \ccxt\bitmex {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
            ),
            'urls' => array(
                'test' => array(
                    'ws' => 'wss://testnet.bitmex.com/realtime',
                ),
                'api' => array(
                    'ws' => 'wss://www.bitmex.com/realtime',
                ),
            ),
            'versions' => array(
                'ws' => '0.2.0',
            ),
            'options' => array(
                'watchOrderBookLevel' => 'orderBookL2', // 'orderBookL2' = L2 full order book, 'orderBookL2_25' = L2 top 25, 'orderBook10' L3 top 10
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                    ),
                    'broad' => array(
                        'Rate limit exceeded' => '\\ccxt\\RateLimitExceeded',
                    ),
                ),
            ),
        ));
    }

    public function watch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $name = 'instrument';
        $messageHash = $name . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        return $this->watch($url, $messageHash, array_merge($request, $params), $messageHash);
    }

    public function handle_ticker($client, $message) {
        //
        //     {
        //         $table => 'instrument',
        //         action => 'partial',
        //         keys => array( 'symbol' ),
        //         types => array(
        //             $symbol => 'symbol',
        //             rootSymbol => 'symbol',
        //             state => 'symbol',
        //             typ => 'symbol',
        //             listing => 'timestamp',
        //             front => 'timestamp',
        //             expiry => 'timestamp',
        //             settle => 'timestamp',
        //             relistInterval => 'timespan',
        //             inverseLeg => 'symbol',
        //             sellLeg => 'symbol',
        //             buyLeg => 'symbol',
        //             optionStrikePcnt => 'float',
        //             optionStrikeRound => 'float',
        //             optionStrikePrice => 'float',
        //             optionMultiplier => 'float',
        //             positionCurrency => 'symbol',
        //             underlying => 'symbol',
        //             quoteCurrency => 'symbol',
        //             underlyingSymbol => 'symbol',
        //             reference => 'symbol',
        //             referenceSymbol => 'symbol',
        //             calcInterval => 'timespan',
        //             publishInterval => 'timespan',
        //             publishTime => 'timespan',
        //             maxOrderQty => 'long',
        //             maxPrice => 'float',
        //             lotSize => 'long',
        //             tickSize => 'float',
        //             multiplier => 'long',
        //             settlCurrency => 'symbol',
        //             underlyingToPositionMultiplier => 'long',
        //             underlyingToSettleMultiplier => 'long',
        //             quoteToSettleMultiplier => 'long',
        //             isQuanto => 'boolean',
        //             isInverse => 'boolean',
        //             initMargin => 'float',
        //             maintMargin => 'float',
        //             riskLimit => 'long',
        //             riskStep => 'long',
        //             limit => 'float',
        //             capped => 'boolean',
        //             taxed => 'boolean',
        //             deleverage => 'boolean',
        //             makerFee => 'float',
        //             takerFee => 'float',
        //             settlementFee => 'float',
        //             insuranceFee => 'float',
        //             fundingBaseSymbol => 'symbol',
        //             fundingQuoteSymbol => 'symbol',
        //             fundingPremiumSymbol => 'symbol',
        //             fundingTimestamp => 'timestamp',
        //             fundingInterval => 'timespan',
        //             fundingRate => 'float',
        //             indicativeFundingRate => 'float',
        //             rebalanceTimestamp => 'timestamp',
        //             rebalanceInterval => 'timespan',
        //             openingTimestamp => 'timestamp',
        //             closingTimestamp => 'timestamp',
        //             sessionInterval => 'timespan',
        //             prevClosePrice => 'float',
        //             limitDownPrice => 'float',
        //             limitUpPrice => 'float',
        //             bankruptLimitDownPrice => 'float',
        //             bankruptLimitUpPrice => 'float',
        //             prevTotalVolume => 'long',
        //             totalVolume => 'long',
        //             volume => 'long',
        //             volume24h => 'long',
        //             prevTotalTurnover => 'long',
        //             totalTurnover => 'long',
        //             turnover => 'long',
        //             turnover24h => 'long',
        //             homeNotional24h => 'float',
        //             foreignNotional24h => 'float',
        //             prevPrice24h => 'float',
        //             vwap => 'float',
        //             highPrice => 'float',
        //             lowPrice => 'float',
        //             lastPrice => 'float',
        //             lastPriceProtected => 'float',
        //             lastTickDirection => 'symbol',
        //             lastChangePcnt => 'float',
        //             bidPrice => 'float',
        //             midPrice => 'float',
        //             askPrice => 'float',
        //             impactBidPrice => 'float',
        //             impactMidPrice => 'float',
        //             impactAskPrice => 'float',
        //             hasLiquidity => 'boolean',
        //             openInterest => 'long',
        //             openValue => 'long',
        //             fairMethod => 'symbol',
        //             fairBasisRate => 'float',
        //             fairBasis => 'float',
        //             fairPrice => 'float',
        //             markMethod => 'symbol',
        //             markPrice => 'float',
        //             indicativeTaxRate => 'float',
        //             indicativeSettlePrice => 'float',
        //             optionUnderlyingPrice => 'float',
        //             settledPrice => 'float',
        //             timestamp => 'timestamp'
        //         ),
        //         foreignKeys => array(
        //             inverseLeg => 'instrument',
        //             sellLeg => 'instrument',
        //             buyLeg => 'instrument'
        //         ),
        //         attributes => array( $symbol => 'unique' ),
        //         filter => array( $symbol => 'XBTUSD' ),
        //         $data => array(
        //             {
        //                 $symbol => 'XBTUSD',
        //                 rootSymbol => 'XBT',
        //                 state => 'Open',
        //                 typ => 'FFWCSX',
        //                 listing => '2016-05-13T12:00:00.000Z',
        //                 front => '2016-05-13T12:00:00.000Z',
        //                 expiry => null,
        //                 settle => null,
        //                 relistInterval => null,
        //                 inverseLeg => '',
        //                 sellLeg => '',
        //                 buyLeg => '',
        //                 optionStrikePcnt => null,
        //                 optionStrikeRound => null,
        //                 optionStrikePrice => null,
        //                 optionMultiplier => null,
        //                 positionCurrency => 'USD',
        //                 underlying => 'XBT',
        //                 quoteCurrency => 'USD',
        //                 underlyingSymbol => 'XBT=',
        //                 reference => 'BMEX',
        //                 referenceSymbol => '.BXBT',
        //                 calcInterval => null,
        //                 publishInterval => null,
        //                 publishTime => null,
        //                 maxOrderQty => 10000000,
        //                 maxPrice => 1000000,
        //                 lotSize => 1,
        //                 tickSize => 0.5,
        //                 multiplier => -100000000,
        //                 settlCurrency => 'XBt',
        //                 underlyingToPositionMultiplier => null,
        //                 underlyingToSettleMultiplier => -100000000,
        //                 quoteToSettleMultiplier => null,
        //                 isQuanto => false,
        //                 isInverse => true,
        //                 initMargin => 0.01,
        //                 maintMargin => 0.005,
        //                 riskLimit => 20000000000,
        //                 riskStep => 10000000000,
        //                 limit => null,
        //                 capped => false,
        //                 taxed => true,
        //                 deleverage => true,
        //                 makerFee => -0.00025,
        //                 takerFee => 0.00075,
        //                 settlementFee => 0,
        //                 insuranceFee => 0,
        //                 fundingBaseSymbol => '.XBTBON8H',
        //                 fundingQuoteSymbol => '.USDBON8H',
        //                 fundingPremiumSymbol => '.XBTUSDPI8H',
        //                 fundingTimestamp => '2020-01-29T12:00:00.000Z',
        //                 fundingInterval => '2000-01-01T08:00:00.000Z',
        //                 fundingRate => 0.000597,
        //                 indicativeFundingRate => 0.000652,
        //                 rebalanceTimestamp => null,
        //                 rebalanceInterval => null,
        //                 openingTimestamp => '2020-01-29T11:00:00.000Z',
        //                 closingTimestamp => '2020-01-29T12:00:00.000Z',
        //                 sessionInterval => '2000-01-01T01:00:00.000Z',
        //                 prevClosePrice => 9063.96,
        //                 limitDownPrice => null,
        //                 limitUpPrice => null,
        //                 bankruptLimitDownPrice => null,
        //                 bankruptLimitUpPrice => null,
        //                 prevTotalVolume => 1989881049026,
        //                 totalVolume => 1990196740950,
        //                 volume => 315691924,
        //                 volume24h => 4491824765,
        //                 prevTotalTurnover => 27865497128425564,
        //                 totalTurnover => 27868891594857150,
        //                 turnover => 3394466431587,
        //                 turnover24h => 48863390064843,
        //                 homeNotional24h => 488633.9006484273,
        //                 foreignNotional24h => 4491824765,
        //                 prevPrice24h => 9091,
        //                 vwap => 9192.8663,
        //                 highPrice => 9440,
        //                 lowPrice => 8886,
        //                 lastPrice => 9287,
        //                 lastPriceProtected => 9287,
        //                 lastTickDirection => 'PlusTick',
        //                 lastChangePcnt => 0.0216,
        //                 bidPrice => 9286,
        //                 midPrice => 9286.25,
        //                 askPrice => 9286.5,
        //                 impactBidPrice => 9285.9133,
        //                 impactMidPrice => 9286.75,
        //                 impactAskPrice => 9287.6382,
        //                 hasLiquidity => true,
        //                 openInterest => 967826984,
        //                 openValue => 10432207060536,
        //                 fairMethod => 'FundingRate',
        //                 fairBasisRate => 0.6537149999999999,
        //                 fairBasis => 0.33,
        //                 fairPrice => 9277.2,
        //                 markMethod => 'FairPrice',
        //                 markPrice => 9277.2,
        //                 indicativeTaxRate => 0,
        //                 indicativeSettlePrice => 9276.87,
        //                 optionUnderlyingPrice => null,
        //                 settledPrice => null,
        //                 timestamp => '2020-01-29T11:31:37.114Z'
        //             }
        //         )
        //     }
        //
        $table = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $update = $data[$i];
            $marketId = $this->safe_value($update, 'symbol');
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $messageHash = $table . ':' . $marketId;
            $ticker = $this->safe_value($this->tickers, $symbol, array());
            $info = $this->safe_value($ticker, 'info', array());
            $ticker = $this->parse_ticker(array_merge($info, $update), $market);
            $this->tickers[$symbol] = $ticker;
            $client->resolve ($ticker, $messageHash);
        }
        return $message;
    }

    public function watch_balance($params = array ()) {
        $this->load_markets();
        $authenticate = $this->authenticate();
        $messageHash = 'margin';
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        return $this->after_dropped($authenticate, array($this, 'watch'), $url, $messageHash, array_merge($request, $params), $messageHash);
    }

    public function handle_balance($client, $message) {
        //
        //     {
        //         table => 'margin',
        //         action => 'partial',
        //         keys => array( 'account' ),
        //         types => array(
        //             account => 'long',
        //             currency => 'symbol',
        //             riskLimit => 'long',
        //             prevState => 'symbol',
        //             state => 'symbol',
        //             action => 'symbol',
        //             amount => 'long',
        //             pendingCredit => 'long',
        //             pendingDebit => 'long',
        //             confirmedDebit => 'long',
        //             prevRealisedPnl => 'long',
        //             prevUnrealisedPnl => 'long',
        //             grossComm => 'long',
        //             grossOpenCost => 'long',
        //             grossOpenPremium => 'long',
        //             grossExecCost => 'long',
        //             grossMarkValue => 'long',
        //             riskValue => 'long',
        //             taxableMargin => 'long',
        //             initMargin => 'long',
        //             maintMargin => 'long',
        //             sessionMargin => 'long',
        //             targetExcessMargin => 'long',
        //             varMargin => 'long',
        //             realisedPnl => 'long',
        //             unrealisedPnl => 'long',
        //             indicativeTax => 'long',
        //             unrealisedProfit => 'long',
        //             syntheticMargin => 'long',
        //             walletBalance => 'long',
        //             marginBalance => 'long',
        //             marginBalancePcnt => 'float',
        //             marginLeverage => 'float',
        //             marginUsedPcnt => 'float',
        //             excessMargin => 'long',
        //             excessMarginPcnt => 'float',
        //             availableMargin => 'long',
        //             withdrawableMargin => 'long',
        //             timestamp => 'timestamp',
        //             grossLastValue => 'long',
        //             commission => 'float'
        //         ),
        //         foreignKeys => array(),
        //         attributes => array( account => 'sorted' ),
        //         filter => array( account => 1455728 ),
        //         $data => array(
        //             {
        //                 account => 1455728,
        //                 currency => 'XBt',
        //                 riskLimit => 1000000000000,
        //                 prevState => '',
        //                 state => '',
        //                 action => '',
        //                 amount => 263542,
        //                 pendingCredit => 0,
        //                 pendingDebit => 0,
        //                 confirmedDebit => 0,
        //                 prevRealisedPnl => 0,
        //                 prevUnrealisedPnl => 0,
        //                 grossComm => 0,
        //                 grossOpenCost => 0,
        //                 grossOpenPremium => 0,
        //                 grossExecCost => 0,
        //                 grossMarkValue => 0,
        //                 riskValue => 0,
        //                 taxableMargin => 0,
        //                 initMargin => 0,
        //                 maintMargin => 0,
        //                 sessionMargin => 0,
        //                 targetExcessMargin => 0,
        //                 varMargin => 0,
        //                 realisedPnl => 0,
        //                 unrealisedPnl => 0,
        //                 indicativeTax => 0,
        //                 unrealisedProfit => 0,
        //                 syntheticMargin => null,
        //                 walletBalance => 263542,
        //                 marginBalance => 263542,
        //                 marginBalancePcnt => 1,
        //                 marginLeverage => 0,
        //                 marginUsedPcnt => 0,
        //                 excessMargin => 263542,
        //                 excessMarginPcnt => 1,
        //                 availableMargin => 263542,
        //                 withdrawableMargin => 263542,
        //                 timestamp => '2020-08-03T12:01:01.246Z',
        //                 grossLastValue => 0,
        //                 commission => null
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($message, 'data');
        $balance = $this->parse_balance_response($data);
        $this->balance = array_merge($this->balance, $balance);
        $messageHash = $this->safe_string($message, 'table');
        $client->resolve ($this->balance, $messageHash);
    }

    public function handle_trades($client, $message) {
        //
        // initial snapshot
        //
        //     {
        //         $table => 'trade',
        //         action => 'partial',
        //         keys => array(),
        //         types => array(
        //             timestamp => 'timestamp',
        //             $symbol => 'symbol',
        //             side => 'symbol',
        //             size => 'long',
        //             price => 'float',
        //             tickDirection => 'symbol',
        //             trdMatchID => 'guid',
        //             grossValue => 'long',
        //             homeNotional => 'float',
        //             foreignNotional => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument', side => 'side' ),
        //         attributes => array( timestamp => 'sorted', $symbol => 'grouped' ),
        //         filter => array( $symbol => 'XBTUSD' ),
        //         $data => array(
        //             {
        //                 timestamp => '2020-01-30T17:03:07.854Z',
        //                 $symbol => 'XBTUSD',
        //                 side => 'Buy',
        //                 size => 15000,
        //                 price => 9378,
        //                 tickDirection => 'ZeroPlusTick',
        //                 trdMatchID => '5b426e7f-83d1-2c80-295d-ee995b8ceb4a',
        //                 grossValue => 159945000,
        //                 homeNotional => 1.59945,
        //                 foreignNotional => 15000
        //             }
        //         )
        //     }
        //
        // updates
        //
        //     {
        //         $table => 'trade',
        //         action => 'insert',
        //         $data => array(
        //             {
        //                 timestamp => '2020-01-30T17:31:40.160Z',
        //                 $symbol => 'XBTUSD',
        //                 side => 'Sell',
        //                 size => 37412,
        //                 price => 9521.5,
        //                 tickDirection => 'ZeroMinusTick',
        //                 trdMatchID => 'a4bfc6bc-6cf1-1a11-622e-270eef8ca5c7',
        //                 grossValue => 392938236,
        //                 homeNotional => 3.92938236,
        //                 foreignNotional => 37412
        //             }
        //         )
        //     }
        //
        $table = 'trade';
        $data = $this->safe_value($message, 'data', array());
        $dataByMarketIds = $this->group_by($data, 'symbol');
        $marketIds = is_array($dataByMarketIds) ? array_keys($dataByMarketIds) : array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId);
            $messageHash = $table . ':' . $marketId;
            $symbol = $market['symbol'];
            $trades = $this->parse_trades($dataByMarketIds[$marketId], $market);
            $stored = $this->safe_value($this->trades, $symbol);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                $stored = new ArrayCache ($limit);
                $this->trades[$symbol] = $stored;
            }
            for ($j = 0; $j < count($trades); $j++) {
                $stored->append ($trades[$j]);
            }
            $client->resolve ($stored, $messageHash);
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $table = 'trade';
        $messageHash = $table . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        $future = $this->watch($url, $messageHash, array_merge($request, $params), $messageHash);
        return $this->after($future, array($this, 'filter_by_since_limit'), $since, $limit, 'timestamp', true);
    }

    public function authenticate($params = array ()) {
        $url = $this->urls['api']['ws'];
        $client = $this->client($url);
        $future = $client->future ('authenticated');
        $action = 'authKeyExpires';
        $authenticated = $this->safe_value($client->subscriptions, $action);
        if ($authenticated === null) {
            try {
                $this->check_required_credentials();
                $timestamp = $this->milliseconds();
                $message = 'GET' . '/realtime' . (string) $timestamp;
                $signature = $this->hmac($this->encode($message), $this->encode($this->secret));
                $request = array(
                    'op' => $action,
                    'args' => array(
                        $this->apiKey,
                        $timestamp,
                        $signature,
                    ),
                );
                $this->spawn(array($this, 'watch'), $url, $action, $request, $action);
            } catch (Exception $e) {
                $client->reject ($e, 'authenticated');
                if (is_array($client->subscriptions) && array_key_exists($action, $client->subscriptions)) {
                    unset($client->subscriptions[$action]);
                }
            }
        }
        return $future;
    }

    public function handle_authentication_message($client, $message) {
        $authenticated = $this->safe_value($message, 'success', false);
        if ($authenticated) {
            // we resolve the $future here permanently so authentication only happens once
            $future = $this->safe_value($client->futures, 'authenticated');
            $future->resolve (true);
        } else {
            $error = new AuthenticationError ($this->json($message));
            $client->reject ($error, 'authenticated');
            // allows further authentication attempts
            $event = 'authKeyExpires';
            if (is_array($client->subscriptions) && array_key_exists($event, $client->subscriptions)) {
                unset($client->subscriptions[$event]);
            }
        }
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $authenticate = $this->authenticate();
        $name = 'order';
        $subscriptionHash = $name;
        $messageHash = $name;
        if ($symbol !== null) {
            $messageHash .= ':' . $symbol;
        }
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $subscriptionHash,
            ),
        );
        $future = $this->after_dropped($authenticate, array($this, 'watch'), $url, $messageHash, $request, $subscriptionHash);
        return $this->after($future, array($this, 'filter_by_symbol_since_limit'), $symbol, $since, $limit);
    }

    public function handle_orders($client, $message) {
        //
        //     {
        //         table => 'order',
        //         action => 'partial',
        //         $keys => array( 'orderID' ),
        //         types => array(
        //             orderID => 'guid',
        //             clOrdID => 'string',
        //             clOrdLinkID => 'symbol',
        //             account => 'long',
        //             $symbol => 'symbol',
        //             side => 'symbol',
        //             simpleOrderQty => 'float',
        //             orderQty => 'long',
        //             price => 'float',
        //             displayQty => 'long',
        //             stopPx => 'float',
        //             pegOffsetValue => 'float',
        //             pegPriceType => 'symbol',
        //             currency => 'symbol',
        //             settlCurrency => 'symbol',
        //             ordType => 'symbol',
        //             timeInForce => 'symbol',
        //             execInst => 'symbol',
        //             contingencyType => 'symbol',
        //             exDestination => 'symbol',
        //             ordStatus => 'symbol',
        //             triggered => 'symbol',
        //             workingIndicator => 'boolean',
        //             ordRejReason => 'symbol',
        //             simpleLeavesQty => 'float',
        //             leavesQty => 'long',
        //             simpleCumQty => 'float',
        //             cumQty => 'long',
        //             avgPx => 'float',
        //             multiLegReportingType => 'symbol',
        //             text => 'string',
        //             transactTime => 'timestamp',
        //             timestamp => 'timestamp'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument', side => 'side', ordStatus => 'ordStatus' ),
        //         attributes => array(
        //             orderID => 'grouped',
        //             account => 'grouped',
        //             ordStatus => 'grouped',
        //             workingIndicator => 'grouped'
        //         ),
        //         filter => array( account => 1455728 ),
        //         $data => array(
        //             {
        //                 orderID => '56222c7a-9956-413a-82cf-99f4812c214b',
        //                 clOrdID => '',
        //                 clOrdLinkID => '',
        //                 account => 1455728,
        //                 $symbol => 'XBTUSD',
        //                 side => 'Sell',
        //                 simpleOrderQty => null,
        //                 orderQty => 1,
        //                 price => 40000,
        //                 displayQty => null,
        //                 stopPx => null,
        //                 pegOffsetValue => null,
        //                 pegPriceType => '',
        //                 currency => 'USD',
        //                 settlCurrency => 'XBt',
        //                 ordType => 'Limit',
        //                 timeInForce => 'GoodTillCancel',
        //                 execInst => '',
        //                 contingencyType => '',
        //                 exDestination => 'XBME',
        //                 ordStatus => 'New',
        //                 triggered => '',
        //                 workingIndicator => true,
        //                 ordRejReason => '',
        //                 simpleLeavesQty => null,
        //                 leavesQty => 1,
        //                 simpleCumQty => null,
        //                 cumQty => 0,
        //                 avgPx => null,
        //                 multiLegReportingType => 'SingleSecurity',
        //                 text => 'Submitted via API.',
        //                 transactTime => '2021-01-02T21:38:49.246Z',
        //                 timestamp => '2021-01-02T21:38:49.246Z'
        //             }
        //         )
        //     }
        //
        //     {
        //         table => 'order',
        //         action => 'insert',
        //         $data => array(
        //             {
        //                 orderID => 'fa993d8e-f7e4-46ed-8097-04f8e9393585',
        //                 clOrdID => '',
        //                 clOrdLinkID => '',
        //                 account => 1455728,
        //                 $symbol => 'XBTUSD',
        //                 side => 'Sell',
        //                 simpleOrderQty => null,
        //                 orderQty => 1,
        //                 price => 40000,
        //                 displayQty => null,
        //                 stopPx => null,
        //                 pegOffsetValue => null,
        //                 pegPriceType => '',
        //                 currency => 'USD',
        //                 settlCurrency => 'XBt',
        //                 ordType => 'Limit',
        //                 timeInForce => 'GoodTillCancel',
        //                 execInst => '',
        //                 contingencyType => '',
        //                 exDestination => 'XBME',
        //                 ordStatus => 'New',
        //                 triggered => '',
        //                 workingIndicator => true,
        //                 ordRejReason => '',
        //                 simpleLeavesQty => null,
        //                 leavesQty => 1,
        //                 simpleCumQty => null,
        //                 cumQty => 0,
        //                 avgPx => null,
        //                 multiLegReportingType => 'SingleSecurity',
        //                 text => 'Submitted via API.',
        //                 transactTime => '2021-01-02T23:49:02.286Z',
        //                 timestamp => '2021-01-02T23:49:02.286Z'
        //             }
        //         )
        //     }
        //
        //
        //
        //     {
        //         table => 'order',
        //         action => 'update',
        //         $data => array(
        //             {
        //                 orderID => 'fa993d8e-f7e4-46ed-8097-04f8e9393585',
        //                 ordStatus => 'Canceled',
        //                 workingIndicator => false,
        //                 leavesQty => 0,
        //                 text => 'Canceled => Canceled via API.\nSubmitted via API.',
        //                 timestamp => '2021-01-02T23:50:51.272Z',
        //                 clOrdID => '',
        //                 account => 1455728,
        //                 $symbol => 'XBTUSD'
        //             }
        //         )
        //     }
        //
        // console.dir ($message, array( depth => null ));
        $data = $this->safe_value($message, 'data', array());
        $messageHash = 'order';
        // initial subscription response with multiple orders
        $dataLength = is_array($data) ? count($data) : 0;
        if ($dataLength > 0) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheById ($limit);
            }
            $stored = $this->orders;
            $symbols = array();
            for ($i = 0; $i < $dataLength; $i++) {
                $currentOrder = $data[$i];
                $orderId = $this->safe_string($currentOrder, 'orderID');
                $previousOrder = $this->safe_value($stored->index, $orderId);
                $rawOrder = $currentOrder;
                if ($previousOrder !== null) {
                    $rawOrder = array_merge($previousOrder['info'], $currentOrder);
                }
                $order = $this->parse_order($rawOrder);
                $stored->append ($order);
                $symbol = $order['symbol'];
                $symbols[$symbol] = true;
            }
            $client->resolve ($this->orders, $messageHash);
            $keys = is_array($symbols) ? array_keys($symbols) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $symbol = $keys[$i];
                $client->resolve ($this->orders, $messageHash . ':' . $symbol);
            }
        }
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $authenticate = $this->authenticate();
        $name = 'execution';
        $subscriptionHash = $name;
        $messageHash = $name;
        if ($symbol !== null) {
            $messageHash .= ':' . $symbol;
        }
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $subscriptionHash,
            ),
        );
        $future = $this->after_dropped($authenticate, array($this, 'watch'), $url, $messageHash, $request, $subscriptionHash);
        return $this->after($future, array($this, 'filter_by_symbol_since_limit'), $symbol, $since, $limit);
    }

    public function handle_my_trades($client, $message) {
        //
        //     {
        //         "table":"execution",
        //         "action":"insert",
        //         "$data":array(
        //             {
        //                 "execID":"0193e879-cb6f-2891-d099-2c4eb40fee21",
        //                 "orderID":"00000000-0000-0000-0000-000000000000",
        //                 "clOrdID":"",
        //                 "clOrdLinkID":"",
        //                 "account":2,
        //                 "$symbol":"XBTUSD",
        //                 "side":"Sell",
        //                 "lastQty":1,
        //                 "lastPx":1134.37,
        //                 "underlyingLastPx":null,
        //                 "lastMkt":"XBME",
        //                 "lastLiquidityInd":"RemovedLiquidity",
        //                 "simpleOrderQty":null,
        //                 "orderQty":1,
        //                 "price":1134.37,
        //                 "displayQty":null,
        //                 "stopPx":null,
        //                 "pegOffsetValue":null,
        //                 "pegPriceType":"",
        //                 "currency":"USD",
        //                 "settlCurrency":"XBt",
        //                 "execType":"Trade",
        //                 "ordType":"Limit",
        //                 "timeInForce":"ImmediateOrCancel",
        //                 "execInst":"",
        //                 "contingencyType":"",
        //                 "exDestination":"XBME",
        //                 "ordStatus":"Filled",
        //                 "triggered":"",
        //                 "workingIndicator":false,
        //                 "ordRejReason":"",
        //                 "simpleLeavesQty":0,
        //                 "leavesQty":0,
        //                 "simpleCumQty":0.001,
        //                 "cumQty":1,
        //                 "avgPx":1134.37,
        //                 "commission":0.00075,
        //                 "tradePublishIndicator":"DoNotPublishTrade",
        //                 "multiLegReportingType":"SingleSecurity",
        //                 "text":"Liquidation",
        //                 "trdMatchID":"7f4ab7f6-0006-3234-76f4-ae1385aad00f",
        //                 "execCost":88155,
        //                 "execComm":66,
        //                 "homeNotional":-0.00088155,
        //                 "foreignNotional":1,
        //                 "transactTime":"2017-04-04T22:07:46.035Z",
        //                 "timestamp":"2017-04-04T22:07:46.035Z"
        //             }
        //         )
        //     }
        //
        $messageHash = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        $dataByExecType = $this->group_by($data, 'execType');
        $rawTrades = $this->safe_value($dataByExecType, 'Trade', array());
        $trades = $this->parse_trades($rawTrades);
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $stored = $this->myTrades;
        $symbols = array();
        for ($j = 0; $j < count($trades); $j++) {
            $trade = $trades[$j];
            $symbol = $trade['symbol'];
            $stored->append ($trade);
            $symbols[$symbol] = $trade;
        }
        $numTrades = is_array($trades) ? count($trades) : 0;
        if ($numTrades > 0) {
            $client->resolve ($stored, $messageHash);
        }
        $keys = is_array($symbols) ? array_keys($symbols) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $client->resolve ($stored, $messageHash . ':' . $keys[$i]);
        }
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        $table = null;
        if ($limit === null) {
            $table = $this->safe_string($this->options, 'watchOrderBookLevel', 'orderBookL2');
        } else if ($limit === 25) {
            $table = 'orderBookL2_25';
        } else if ($limit === 10) {
            $table = 'orderBookL10';
        } else {
            throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null (L2), 25 (L2) or 10 (L3)');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $messageHash = $table . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        $future = $this->watch($url, $messageHash, $this->deep_extend($request, $params), $messageHash);
        return $this->after($future, array($this, 'limit_order_book'), $symbol, $limit, $params);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $table = 'tradeBin' . $this->timeframes[$timeframe];
        $messageHash = $table . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        $future = $this->watch($url, $messageHash, array_merge($request, $params), $messageHash);
        return $this->after($future, array($this, 'filter_by_since_limit'), $since, $limit, 0, true);
    }

    public function handle_ohlcv($client, $message) {
        //
        //     {
        //         $table => 'tradeBin1m',
        //         action => 'partial',
        //         keys => array(),
        //         types => array(
        //             timestamp => 'timestamp',
        //             $symbol => 'symbol',
        //             open => 'float',
        //             high => 'float',
        //             low => 'float',
        //             close => 'float',
        //             trades => 'long',
        //             volume => 'long',
        //             vwap => 'float',
        //             lastSize => 'long',
        //             turnover => 'long',
        //             homeNotional => 'float',
        //             foreignNotional => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument' ),
        //         attributes => array( timestamp => 'sorted', $symbol => 'grouped' ),
        //         filter => array( $symbol => 'XBTUSD' ),
        //         data => array(
        //             {
        //                 timestamp => '2020-02-03T01:13:00.000Z',
        //                 $symbol => 'XBTUSD',
        //                 open => 9395,
        //                 high => 9395.5,
        //                 low => 9394.5,
        //                 close => 9395,
        //                 trades => 221,
        //                 volume => 839204,
        //                 vwap => 9394.9643,
        //                 lastSize => 1874,
        //                 turnover => 8932641535,
        //                 homeNotional => 89.32641534999999,
        //                 foreignNotional => 839204
        //             }
        //         )
        //     }
        //
        //
        //     {
        //         $table => 'tradeBin1m',
        //         action => 'insert',
        //         data => array(
        //             {
        //                 timestamp => '2020-02-03T18:28:00.000Z',
        //                 $symbol => 'XBTUSD',
        //                 open => 9256,
        //                 high => 9256.5,
        //                 low => 9256,
        //                 close => 9256,
        //                 trades => 29,
        //                 volume => 79057,
        //                 vwap => 9256.688,
        //                 lastSize => 100,
        //                 turnover => 854077082,
        //                 homeNotional => 8.540770820000002,
        //                 foreignNotional => 79057
        //             }
        //         )
        //     }
        //
        $table = $this->safe_string($message, 'table');
        $interval = str_replace('tradeBin', '', $table);
        $timeframe = $this->find_timeframe($interval);
        $duration = $this->parse_timeframe($timeframe);
        $candles = $this->safe_value($message, 'data', array());
        $results = array();
        for ($i = 0; $i < count($candles); $i++) {
            $candle = $candles[$i];
            $marketId = $this->safe_string($candle, 'symbol');
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            $messageHash = $table . ':' . $market['id'];
            $result = array(
                $this->parse8601($this->safe_string($candle, 'timestamp')) - $duration * 1000,
                $this->safe_float($candle, 'open'),
                $this->safe_float($candle, 'high'),
                $this->safe_float($candle, 'low'),
                $this->safe_float($candle, 'close'),
                $this->safe_float($candle, 'volume'),
            );
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCache ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $length = is_array($stored) ? count($stored) : 0;
            if ($length && $result[0] === $stored[$length - 1][0]) {
                $stored[$length - 1] = $result;
            } else {
                $stored->append ($result);
            }
            $results[$messageHash] = $stored;
        }
        $messageHashes = is_array($results) ? array_keys($results) : array();
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $client->resolve ($results[$messageHash], $messageHash);
        }
    }

    public function watch_heartbeat($params = array ()) {
        $this->load_markets();
        $event = 'heartbeat';
        $url = $this->urls['api']['ws'];
        return $this->watch($url, $event);
    }

    public function handle_order_book($client, $message) {
        //
        // first snapshot
        //
        //     {
        //         $table => 'orderBookL2',
        //         $action => 'partial',
        //         keys => array( 'symbol', 'id', 'side' ),
        //         types => array(
        //             $symbol => 'symbol',
        //             $id => 'long',
        //             $side => 'symbol',
        //             $size => 'long',
        //             $price => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument', $side => 'side' ),
        //         attributes => array( $symbol => 'parted', $id => 'sorted' ),
        //         $filter => array( $symbol => 'XBTUSD' ),
        //         $data => array(
        //             array( $symbol => 'XBTUSD', $id => 8700000100, $side => 'Sell', $size => 1, $price => 999999 ),
        //             array( $symbol => 'XBTUSD', $id => 8700000200, $side => 'Sell', $size => 3, $price => 999998 ),
        //             array( $symbol => 'XBTUSD', $id => 8716991250, $side => 'Sell', $size => 26, $price => 830087.5 ),
        //             array( $symbol => 'XBTUSD', $id => 8728701950, $side => 'Sell', $size => 1720, $price => 712980.5 ),
        //         )
        //     }
        //
        // subsequent updates
        //
        //     {
        //         $table => 'orderBookL2',
        //         $action => 'update',
        //         $data => array(
        //             array( $symbol => 'XBTUSD', $id => 8799285100, $side => 'Sell', $size => 70590 ),
        //             array( $symbol => 'XBTUSD', $id => 8799285550, $side => 'Sell', $size => 217652 ),
        //             array( $symbol => 'XBTUSD', $id => 8799288950, $side => 'Buy', $size => 47552 ),
        //             array( $symbol => 'XBTUSD', $id => 8799289250, $side => 'Buy', $size => 78217 ),
        //         )
        //     }
        //
        $action = $this->safe_string($message, 'action');
        $table = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        // if it's an initial snapshot
        if ($action === 'partial') {
            $filter = $this->safe_value($message, 'filter', array());
            $marketId = $this->safe_value($filter, 'symbol');
            $market = $this->safe_market($marketId);
            $symbol = $market['symbol'];
            if ($table === 'orderBookL2') {
                $this->orderbooks[$symbol] = $this->indexed_order_book();
            } else if ($table === 'orderBookL2_25') {
                $this->orderbooks[$symbol] = $this->indexed_order_book(array(), 25);
            } else if ($table === 'orderBook10') {
                $this->orderbooks[$symbol] = $this->indexed_order_book(array(), 10);
            }
            $orderbook = $this->orderbooks[$symbol];
            for ($i = 0; $i < count($data); $i++) {
                $price = $this->safe_float($data[$i], 'price');
                $size = $this->safe_float($data[$i], 'size');
                $id = $this->safe_string($data[$i], 'id');
                $side = $this->safe_string($data[$i], 'side');
                $side = ($side === 'Buy') ? 'bids' : 'asks';
                $bookside = $orderbook[$side];
                $bookside->store ($price, $size, $id);
            }
            $messageHash = $table . ':' . $marketId;
            $client->resolve ($orderbook, $messageHash);
        } else {
            $numUpdatesByMarketId = array();
            for ($i = 0; $i < count($data); $i++) {
                $marketId = $this->safe_value($data[$i], 'symbol');
                if (!(is_array($numUpdatesByMarketId) && array_key_exists($marketId, $numUpdatesByMarketId))) {
                    $numUpdatesByMarketId[$marketId] = 0;
                }
                $numUpdatesByMarketId[$marketId] = $this->sum($numUpdatesByMarketId, 1);
                $market = $this->safe_market($marketId);
                $symbol = $market['symbol'];
                $orderbook = $this->orderbooks[$symbol];
                $price = $this->safe_float($data[$i], 'price');
                $size = $this->safe_float($data[$i], 'size', 0);
                $id = $this->safe_string($data[$i], 'id');
                $side = $this->safe_string($data[$i], 'side');
                $side = ($side === 'Buy') ? 'bids' : 'asks';
                $bookside = $orderbook[$side];
                $bookside->store ($price, $size, $id);
            }
            $marketIds = is_array($numUpdatesByMarketId) ? array_keys($numUpdatesByMarketId) : array();
            for ($i = 0; $i < count($marketIds); $i++) {
                $marketId = $marketIds[$i];
                $messageHash = $table . ':' . $marketId;
                $market = $this->safe_market($marketId);
                $symbol = $market['symbol'];
                $orderbook = $this->orderbooks[$symbol];
                $client->resolve ($orderbook, $messageHash);
            }
        }
    }

    public function handle_system_status($client, $message) {
        //
        // todo answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         info => 'Welcome to the BitMEX Realtime API.',
        //         version => '2019-11-22T00:24:37.000Z',
        //         timestamp => '2019-11-23T09:02:27.771Z',
        //         docs => 'https://www.bitmex.com/app/wsAPI',
        //         limit => array( remaining => 39 )
        //     }
        //
        return $message;
    }

    public function handle_subscription_status($client, $message) {
        //
        //     {
        //         success => true,
        //         subscribe => 'orderBookL2:XBTUSD',
        //         request => array( op => 'subscribe', args => array( 'orderBookL2:XBTUSD' ) )
        //     }
        //
        return $message;
    }

    public function handle_error_message($client, $message) {
        //
        // generic $error format
        //
        //     array( "$error" => errorMessage )
        //
        // examples
        //
        //     {
        //         "status" => 429,
        //         "$error" => "Rate limit exceeded, retry in 1 seconds.",
        //         "meta" => array( "retryAfter" => 1 ),
        //         "$request" => array( "op" => "subscribe", "$args" => "orderBook" ),
        //     }
        //
        //     array( "$error" => "Rate limit exceeded, retry in 29 seconds." )
        //
        $error = $this->safe_value($message, 'error');
        if ($error !== null) {
            $request = $this->safe_value($message, 'request', array());
            $args = $this->safe_string($request, 'args', array());
            $numArgs = is_array($args) ? count($args) : 0;
            if ($numArgs > 0) {
                $messageHash = $args[0];
                $broad = $this->exceptions['ws']['broad'];
                $broadKey = $this->find_broadly_matched_key($broad, $error);
                $exception = null;
                if ($broadKey === null) {
                    $exception = new ExchangeError ($error);
                } else {
                    $exception = new $broad[$broadKey] ($error);
                }
                $client->reject ($exception, $messageHash);
                return false;
            }
        }
        return true;
    }

    public function handle_message($client, $message) {
        //
        //     {
        //         info => 'Welcome to the BitMEX Realtime API.',
        //         version => '2019-11-22T00:24:37.000Z',
        //         timestamp => '2019-11-23T09:04:42.569Z',
        //         docs => 'https://www.bitmex.com/app/wsAPI',
        //         limit => array( remaining => 38 )
        //     }
        //
        //     {
        //         success => true,
        //         subscribe => 'orderBookL2:XBTUSD',
        //         $request => array( $op => 'subscribe', args => array( 'orderBookL2:XBTUSD' ) )
        //     }
        //
        //     {
        //         $table => 'orderBookL2',
        //         action => 'update',
        //         data => array(
        //             array( symbol => 'XBTUSD', id => 8799284800, side => 'Sell', size => 721000 ),
        //             array( symbol => 'XBTUSD', id => 8799285100, side => 'Sell', size => 70590 ),
        //             array( symbol => 'XBTUSD', id => 8799285550, side => 'Sell', size => 217652 ),
        //             array( symbol => 'XBTUSD', id => 8799285850, side => 'Sell', size => 105578 ),
        //             array( symbol => 'XBTUSD', id => 8799286350, side => 'Sell', size => 172093 ),
        //             array( symbol => 'XBTUSD', id => 8799286650, side => 'Sell', size => 201125 ),
        //             array( symbol => 'XBTUSD', id => 8799288950, side => 'Buy', size => 47552 ),
        //             array( symbol => 'XBTUSD', id => 8799289250, side => 'Buy', size => 78217 ),
        //             array( symbol => 'XBTUSD', id => 8799289700, side => 'Buy', size => 193677 ),
        //             array( symbol => 'XBTUSD', id => 8799290000, side => 'Buy', size => 818161 ),
        //             array( symbol => 'XBTUSD', id => 8799290500, side => 'Buy', size => 218806 ),
        //             array( symbol => 'XBTUSD', id => 8799290800, side => 'Buy', size => 102946 )
        //         )
        //     }
        //
        if ($this->handle_error_message($client, $message)) {
            $table = $this->safe_string($message, 'table');
            $methods = array(
                'orderBookL2' => array($this, 'handle_order_book'),
                'orderBookL2_25' => array($this, 'handle_order_book'),
                'orderBook10' => array($this, 'handle_order_book'),
                'instrument' => array($this, 'handle_ticker'),
                'trade' => array($this, 'handle_trades'),
                'tradeBin1m' => array($this, 'handle_ohlcv'),
                'tradeBin5m' => array($this, 'handle_ohlcv'),
                'tradeBin1h' => array($this, 'handle_ohlcv'),
                'tradeBin1d' => array($this, 'handle_ohlcv'),
                'order' => array($this, 'handle_orders'),
                'execution' => array($this, 'handle_my_trades'),
                'margin' => array($this, 'handle_balance'),
            );
            $method = $this->safe_value($methods, $table);
            if ($method === null) {
                $request = $this->safe_value($message, 'request', array());
                $op = $this->safe_value($request, 'op');
                if ($op === 'authKeyExpires') {
                    return $this->handle_authentication_message($client, $message);
                } else {
                    return $message;
                }
            } else {
                return $method($client, $message);
            }
        }
    }
}
